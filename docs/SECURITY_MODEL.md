# Модель безопасности (текущее состояние → целевое)

## 1) Коротко: что защищаем

- **Данные пользователей**: телефон/профиль, история бронирований, потенциально
  медиа (фото/видео для анализа).
- **Деньги/квоты**: API‑квоты Gemini, стоимость генераций (особенно видео).
- **Репутация**: безопасность контента (XSS), утечки, злоупотребления
  (spam/DoS).

## 2) Текущие риски (факты по коду)

### 2.1 Клиентский ключ Gemini (High)

Сейчас ключ Gemini **вшивается в клиентский bundle** через `define` в
`vite.config.ts` (WEB/APP).  
Следствие: ключ можно извлечь из JS, использовать вне приложения → расход
квот/денег.

### 2.2 XSS поверхность в Blog (Medium → High при внешнем контенте)

- В `shared/components/Blog.tsx` HTML санитизируется DOMPurify (allowlist).
- В `k-sebe-yoga-studioWEB/components/Blog.tsx` и
  `k-sebe-yoga-studio-APPp/components/Blog.tsx` ранее была прямая вставка
  HTML.  
  (В рамках текущей работы добавлена санитизация в WEB/APP, чтобы приблизить их
  к shared-подходу.)

### 2.3 “Auth” в APP — не Supabase Auth (High, бизнес‑риск)

Текущая модель — пользователь “логинится” по телефону, профайл кешируется
локально, а в Supabase делается `upsert` в таблицу `profiles`.  
Это **не даёт серверной идентичности** (нет сессии/OTP), а значит любые
ограничения «по пользователю» легко обходятся.

## 3) Целевое состояние (безопасный контур)

### 3.1 AI Proxy (Edge Function)

**Идея**: клиент не знает ключа Gemini. Клиент вызывает
`/functions/v1/gemini-proxy`, а ключ хранится как серверный секрет
`GEMINI_API_KEY`.

Минимальный набор защит:

- **Auth required** (Supabase Auth) → получаем `user_id`
- **Rate limit** по `user_id` + по IP (минимум)
- **Лимиты модели/модальности** (запрет дорогих режимов для free tier)
- **Серверный лог** (метрики расходов)

Текущее состояние в репозитории:

- Добавлен Supabase Edge Function: `supabase/functions/gemini-proxy/index.ts`
- WEB/APP `geminiService.ts` сначала пытаются вызвать proxy, и только затем (для
  локального демо) используют клиентский ключ.
- В proxy добавлен rate limiting:
  - по `user_id`, если пришёл валидный Supabase JWT
  - иначе fallback по IP
  - отдельные лимиты для “дорогих” операций (генерация/анализ медиа)
- В proxy включено правило: **дорогие операции требуют аутентификации** (иначе
  `401`).

### 3.2 Supabase RLS и таблицы

Любые таблицы с пользовательскими данными должны иметь:

- `user_id` (FK на `auth.users`)
- RLS policy: `auth.uid() = user_id`

## 4) Порядок закрытия рисков (практично)

### Фаза 0 (1–2 недели)

- [ ] Вынести Gemini в proxy (Edge Function) + server‑secret `GEMINI_API_KEY`
- [ ] Включить Supabase Auth (OTP/Email) для APP
- [ ] Rate limiting + базовые лимиты по тарифу

### Фаза 1 (2–4 недели)

- [ ] Ввести роли/права админа (для управления расписанием)
- [ ] Наблюдаемость: Sentry/логирование ошибок, метрики AI расходов

## 5) Принципы (чтобы не “разъехалось” снова)

- **Секреты никогда не живут в клиенте**, кроме публичных ключей (например,
  платежные public keys).
- **XSS‑защита по умолчанию**: любые HTML‑поля всегда санитизируются в одном
  месте (желательно `shared/utils/sanitizeHtml`).
- **Auth‑first**: всё, что связано с деньгами/квотами/персональными данными,
  требует серверной идентичности.
